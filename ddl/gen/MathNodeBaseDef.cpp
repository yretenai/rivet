// <auto-generated>
// rivet project
// Copyright (c) 2023 <https://github.com/yretenai/rivet>
// SPDX-License-Identifier: MPL-2.0

#include <rivet/ddl/generated/MinFloatNodeDef.hpp>
#include <rivet/ddl/generated/CompareIntsInlineNodeDef.hpp>
#include <rivet/ddl/generated/RandomFloatGeneratorNodeDef.hpp>
#include <rivet/ddl/generated/NormalizeVectorNodeDef.hpp>
#include <rivet/ddl/generated/VecToFloatsNodeDef.hpp>
#include <rivet/ddl/generated/CompareFloatsNodeDef.hpp>
#include <rivet/ddl/generated/VectorLengthNodeDef.hpp>
#include <rivet/ddl/generated/VecDistanceNodeDef.hpp>
#include <rivet/ddl/generated/SubtractVectorsNodeDef.hpp>
#include <rivet/ddl/generated/AddFloatsNodeDef.hpp>
#include <rivet/ddl/generated/AddVectorsNodeDef.hpp>
#include <rivet/ddl/generated/MultiplyVectorByScalarNodeDef.hpp>
#include <rivet/ddl/generated/MultiplyFloatsNodeDef.hpp>
#include <rivet/ddl/generated/NormalizeFloatNodeDef.hpp>
#include <rivet/ddl/generated/CompareIntsNodeDef.hpp>
#include <rivet/ddl/generated/NegateVectorNodeDef.hpp>
#include <rivet/ddl/generated/SubtractFloatsNodeDef.hpp>
#include <rivet/ddl/generated/RandomIntGeneratorNodeDef.hpp>
#include <rivet/ddl/generated/FloatsToVecNodeDef.hpp>
#include <rivet/ddl/generated/DivideFloatsNodeDef.hpp>
#include <rivet/ddl/generated/MaxFloatNodeDef.hpp>
#include <rivet/ddl/generated/CompareFloatsInlineNodeDef.hpp>
#include <rivet/ddl/generated/ClampFloatNodeDef.hpp> 

#include <rivet/ddl/generated/MathNodeBaseDef.hpp>

namespace rivet::ddl::generated {
	MathNodeBaseDef::MathNodeBaseDef([[maybe_unused]] const std::shared_ptr<const rivet::structures::rivet_serialized_object> &serialized): NodeBaseDef(serialized) {

	}

	[[nodiscard]] auto
	MathNodeBaseDef::get_type_name() const noexcept -> std::string_view {
		return type_name;
	}

	[[nodiscard]] auto
	MathNodeBaseDef::from_substruct(rivet_type_id incoming_type_id, const std::shared_ptr<const rivet::structures::rivet_serialized_object> &serialized) -> std::shared_ptr<MathNodeBaseDef> {
		if (incoming_type_id == MathNodeBaseDef::type_id) {
			return std::make_shared<MathNodeBaseDef>(serialized);
		}

		auto FloatsToVecNodeDef_ptr = FloatsToVecNodeDef::from_substruct(incoming_type_id, serialized);
		if (FloatsToVecNodeDef_ptr != nullptr) {
			return FloatsToVecNodeDef_ptr;
		}

		auto AddFloatsNodeDef_ptr = AddFloatsNodeDef::from_substruct(incoming_type_id, serialized);
		if (AddFloatsNodeDef_ptr != nullptr) {
			return AddFloatsNodeDef_ptr;
		}

		auto MultiplyFloatsNodeDef_ptr = MultiplyFloatsNodeDef::from_substruct(incoming_type_id, serialized);
		if (MultiplyFloatsNodeDef_ptr != nullptr) {
			return MultiplyFloatsNodeDef_ptr;
		}

		auto SubtractFloatsNodeDef_ptr = SubtractFloatsNodeDef::from_substruct(incoming_type_id, serialized);
		if (SubtractFloatsNodeDef_ptr != nullptr) {
			return SubtractFloatsNodeDef_ptr;
		}

		auto MaxFloatNodeDef_ptr = MaxFloatNodeDef::from_substruct(incoming_type_id, serialized);
		if (MaxFloatNodeDef_ptr != nullptr) {
			return MaxFloatNodeDef_ptr;
		}

		auto CompareFloatsInlineNodeDef_ptr = CompareFloatsInlineNodeDef::from_substruct(incoming_type_id, serialized);
		if (CompareFloatsInlineNodeDef_ptr != nullptr) {
			return CompareFloatsInlineNodeDef_ptr;
		}

		auto AddVectorsNodeDef_ptr = AddVectorsNodeDef::from_substruct(incoming_type_id, serialized);
		if (AddVectorsNodeDef_ptr != nullptr) {
			return AddVectorsNodeDef_ptr;
		}

		auto SubtractVectorsNodeDef_ptr = SubtractVectorsNodeDef::from_substruct(incoming_type_id, serialized);
		if (SubtractVectorsNodeDef_ptr != nullptr) {
			return SubtractVectorsNodeDef_ptr;
		}

		auto NormalizeFloatNodeDef_ptr = NormalizeFloatNodeDef::from_substruct(incoming_type_id, serialized);
		if (NormalizeFloatNodeDef_ptr != nullptr) {
			return NormalizeFloatNodeDef_ptr;
		}

		auto NegateVectorNodeDef_ptr = NegateVectorNodeDef::from_substruct(incoming_type_id, serialized);
		if (NegateVectorNodeDef_ptr != nullptr) {
			return NegateVectorNodeDef_ptr;
		}

		auto MultiplyVectorByScalarNodeDef_ptr = MultiplyVectorByScalarNodeDef::from_substruct(incoming_type_id, serialized);
		if (MultiplyVectorByScalarNodeDef_ptr != nullptr) {
			return MultiplyVectorByScalarNodeDef_ptr;
		}

		auto DivideFloatsNodeDef_ptr = DivideFloatsNodeDef::from_substruct(incoming_type_id, serialized);
		if (DivideFloatsNodeDef_ptr != nullptr) {
			return DivideFloatsNodeDef_ptr;
		}

		auto ClampFloatNodeDef_ptr = ClampFloatNodeDef::from_substruct(incoming_type_id, serialized);
		if (ClampFloatNodeDef_ptr != nullptr) {
			return ClampFloatNodeDef_ptr;
		}

		auto VectorLengthNodeDef_ptr = VectorLengthNodeDef::from_substruct(incoming_type_id, serialized);
		if (VectorLengthNodeDef_ptr != nullptr) {
			return VectorLengthNodeDef_ptr;
		}

		auto CompareFloatsNodeDef_ptr = CompareFloatsNodeDef::from_substruct(incoming_type_id, serialized);
		if (CompareFloatsNodeDef_ptr != nullptr) {
			return CompareFloatsNodeDef_ptr;
		}

		auto RandomIntGeneratorNodeDef_ptr = RandomIntGeneratorNodeDef::from_substruct(incoming_type_id, serialized);
		if (RandomIntGeneratorNodeDef_ptr != nullptr) {
			return RandomIntGeneratorNodeDef_ptr;
		}

		auto VecToFloatsNodeDef_ptr = VecToFloatsNodeDef::from_substruct(incoming_type_id, serialized);
		if (VecToFloatsNodeDef_ptr != nullptr) {
			return VecToFloatsNodeDef_ptr;
		}

		auto NormalizeVectorNodeDef_ptr = NormalizeVectorNodeDef::from_substruct(incoming_type_id, serialized);
		if (NormalizeVectorNodeDef_ptr != nullptr) {
			return NormalizeVectorNodeDef_ptr;
		}

		auto RandomFloatGeneratorNodeDef_ptr = RandomFloatGeneratorNodeDef::from_substruct(incoming_type_id, serialized);
		if (RandomFloatGeneratorNodeDef_ptr != nullptr) {
			return RandomFloatGeneratorNodeDef_ptr;
		}

		auto CompareIntsInlineNodeDef_ptr = CompareIntsInlineNodeDef::from_substruct(incoming_type_id, serialized);
		if (CompareIntsInlineNodeDef_ptr != nullptr) {
			return CompareIntsInlineNodeDef_ptr;
		}

		auto VecDistanceNodeDef_ptr = VecDistanceNodeDef::from_substruct(incoming_type_id, serialized);
		if (VecDistanceNodeDef_ptr != nullptr) {
			return VecDistanceNodeDef_ptr;
		}

		auto CompareIntsNodeDef_ptr = CompareIntsNodeDef::from_substruct(incoming_type_id, serialized);
		if (CompareIntsNodeDef_ptr != nullptr) {
			return CompareIntsNodeDef_ptr;
		}

		auto MinFloatNodeDef_ptr = MinFloatNodeDef::from_substruct(incoming_type_id, serialized);
		if (MinFloatNodeDef_ptr != nullptr) {
			return MinFloatNodeDef_ptr;
		}
 
		return nullptr;
	}
} // namespace rivet::ddl::generated
