// <auto-generated>
// rivet project
// Copyright (c) 2023 <https://github.com/yretenai/rivet>
// SPDX-License-Identifier: MPL-2.0

#include <rivet/ddl/generated/InputPlugUInt.hpp>
#include <rivet/ddl/generated/InputPlugStringHash.hpp>
#include <rivet/ddl/generated/InputPlugVec3.hpp>
#include <rivet/ddl/generated/InputPlugActor.hpp>
#include <rivet/ddl/generated/InputPlugString.hpp>
#include <rivet/ddl/generated/InputPlugInt.hpp>
#include <rivet/ddl/generated/InputPlugSignal.hpp>
#include <rivet/ddl/generated/InputPlugWeaponMacroType.hpp>
#include <rivet/ddl/generated/InputPlugEventInitialization.hpp>
#include <rivet/ddl/generated/InputPlugFloat.hpp>
#include <rivet/ddl/generated/InputPlugBoolean.hpp> 

#include <rivet/ddl/generated/InputPlugBaseDef.hpp>

namespace rivet::ddl::generated {
	InputPlugBaseDef::InputPlugBaseDef([[maybe_unused]] const std::shared_ptr<const rivet::structures::rivet_serialized_object> &serialized): NodeGraphItemDef(serialized) {

	}

	[[nodiscard]] auto
	InputPlugBaseDef::get_type_name() const noexcept -> std::string_view {
		return type_name;
	}

	[[nodiscard]] auto
	InputPlugBaseDef::from_substruct(rivet_type_id incoming_type_id, const std::shared_ptr<const rivet::structures::rivet_serialized_object> &serialized) -> std::shared_ptr<InputPlugBaseDef> {
		if (incoming_type_id == InputPlugBaseDef::type_id) {
			return std::make_shared<InputPlugBaseDef>(serialized);
		}

		auto InputPlugBoolean_ptr = InputPlugBoolean::from_substruct(incoming_type_id, serialized);
		if (InputPlugBoolean_ptr != nullptr) {
			return InputPlugBoolean_ptr;
		}

		auto InputPlugEventInitialization_ptr = InputPlugEventInitialization::from_substruct(incoming_type_id, serialized);
		if (InputPlugEventInitialization_ptr != nullptr) {
			return InputPlugEventInitialization_ptr;
		}

		auto InputPlugSignal_ptr = InputPlugSignal::from_substruct(incoming_type_id, serialized);
		if (InputPlugSignal_ptr != nullptr) {
			return InputPlugSignal_ptr;
		}

		auto InputPlugVec3_ptr = InputPlugVec3::from_substruct(incoming_type_id, serialized);
		if (InputPlugVec3_ptr != nullptr) {
			return InputPlugVec3_ptr;
		}

		auto InputPlugWeaponMacroType_ptr = InputPlugWeaponMacroType::from_substruct(incoming_type_id, serialized);
		if (InputPlugWeaponMacroType_ptr != nullptr) {
			return InputPlugWeaponMacroType_ptr;
		}

		auto InputPlugInt_ptr = InputPlugInt::from_substruct(incoming_type_id, serialized);
		if (InputPlugInt_ptr != nullptr) {
			return InputPlugInt_ptr;
		}

		auto InputPlugString_ptr = InputPlugString::from_substruct(incoming_type_id, serialized);
		if (InputPlugString_ptr != nullptr) {
			return InputPlugString_ptr;
		}

		auto InputPlugActor_ptr = InputPlugActor::from_substruct(incoming_type_id, serialized);
		if (InputPlugActor_ptr != nullptr) {
			return InputPlugActor_ptr;
		}

		auto InputPlugStringHash_ptr = InputPlugStringHash::from_substruct(incoming_type_id, serialized);
		if (InputPlugStringHash_ptr != nullptr) {
			return InputPlugStringHash_ptr;
		}

		auto InputPlugUInt_ptr = InputPlugUInt::from_substruct(incoming_type_id, serialized);
		if (InputPlugUInt_ptr != nullptr) {
			return InputPlugUInt_ptr;
		}

		auto InputPlugFloat_ptr = InputPlugFloat::from_substruct(incoming_type_id, serialized);
		if (InputPlugFloat_ptr != nullptr) {
			return InputPlugFloat_ptr;
		}
 
		return nullptr;
	}
} // namespace rivet::ddl::generated
