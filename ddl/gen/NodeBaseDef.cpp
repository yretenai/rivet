// <auto-generated>
// rivet project
// Copyright (c) 2023 <https://github.com/yretenai/rivet>
// SPDX-License-Identifier: MPL-2.0

#include <rivet/ddl/generated/TestTriggerNodeDef.hpp>
#include <rivet/ddl/generated/TestNodeDef.hpp>
#include <rivet/ddl/generated/StringHashOutNodeDef.hpp>
#include <rivet/ddl/generated/WeaponMacroTypeStateOutNodeDef.hpp>
#include <rivet/ddl/generated/WAMNodeBaseDef.hpp>
#include <rivet/ddl/generated/EmbeddedGraphNodeBaseDef.hpp>
#include <rivet/ddl/generated/OrMissionSystemNodeDef_Tools.hpp>
#include <rivet/ddl/generated/NodalShotVariableNodeBaseDef.hpp>
#include <rivet/ddl/generated/ActorNodeBaseDef.hpp>
#include <rivet/ddl/generated/LogicNodeBaseDef.hpp>
#include <rivet/ddl/generated/NodalShotEffectNodeBaseDef.hpp>
#include <rivet/ddl/generated/InputNodeBaseDef.hpp>
#include <rivet/ddl/generated/StringOutNodeDef.hpp>
#include <rivet/ddl/generated/NodalShotStateNodeBaseDef.hpp>
#include <rivet/ddl/generated/Vec3OutNodeDef.hpp>
#include <rivet/ddl/generated/MissionSystemNodeBaseDef.hpp>
#include <rivet/ddl/generated/IntOutNodeDef.hpp>
#include <rivet/ddl/generated/ComboNodeBaseDef.hpp>
#include <rivet/ddl/generated/FloatOutNodeDef.hpp>
#include <rivet/ddl/generated/MathNodeBaseDef.hpp>
#include <rivet/ddl/generated/TestMakeStringNodeDef.hpp>
#include <rivet/ddl/generated/UIntOutNodeDef.hpp>
#include <rivet/ddl/generated/NodalShotConditionalNodeDef.hpp>
#include <rivet/ddl/generated/ConditionNodeBaseDef.hpp>
#include <rivet/ddl/generated/AssetReferenceNodeDef.hpp>
#include <rivet/ddl/generated/NotMissionSystemNodeDef_Tools.hpp>
#include <rivet/ddl/generated/MissionNodeGameDef_Tools.hpp>
#include <rivet/ddl/generated/NodalShotEventNodeBaseDef.hpp>
#include <rivet/ddl/generated/AndMissionSystemNodeDef_Tools.hpp>
#include <rivet/ddl/generated/BooleanOutNodeDef.hpp>
#include <rivet/ddl/generated/InitMissionGraphNodeGameDef_Tools.hpp> 

#include <rivet/ddl/generated/NodeBaseDef.hpp>

namespace rivet::ddl::generated {
	NodeBaseDef::NodeBaseDef([[maybe_unused]] const std::shared_ptr<const rivet::structures::rivet_serialized_object> &serialized): NodeGraphItemDef(serialized) {
		Collapsed = serialized->get_bool(Collapsed_type_id, false);
		Disabled = serialized->get_bool(Disabled_type_id, false);
		X = serialized->get_float(X_type_id, 0.000000f);
		Y = serialized->get_float(Y_type_id, 0.000000f); 
	}

	[[nodiscard]] auto
	NodeBaseDef::get_type_name() const noexcept -> std::string_view {
		return type_name;
	}

	[[nodiscard]] auto
	NodeBaseDef::from_substruct(rivet_type_id incoming_type_id, const std::shared_ptr<const rivet::structures::rivet_serialized_object> &serialized) -> std::shared_ptr<NodeBaseDef> {
		if (incoming_type_id == NodeBaseDef::type_id) {
			return std::make_shared<NodeBaseDef>(serialized);
		}

		auto NodalShotStateNodeBaseDef_ptr = NodalShotStateNodeBaseDef::from_substruct(incoming_type_id, serialized);
		if (NodalShotStateNodeBaseDef_ptr != nullptr) {
			return NodalShotStateNodeBaseDef_ptr;
		}

		auto StringOutNodeDef_ptr = StringOutNodeDef::from_substruct(incoming_type_id, serialized);
		if (StringOutNodeDef_ptr != nullptr) {
			return StringOutNodeDef_ptr;
		}

		auto LogicNodeBaseDef_ptr = LogicNodeBaseDef::from_substruct(incoming_type_id, serialized);
		if (LogicNodeBaseDef_ptr != nullptr) {
			return LogicNodeBaseDef_ptr;
		}

		auto MissionSystemNodeBaseDef_ptr = MissionSystemNodeBaseDef::from_substruct(incoming_type_id, serialized);
		if (MissionSystemNodeBaseDef_ptr != nullptr) {
			return MissionSystemNodeBaseDef_ptr;
		}

		auto NodalShotVariableNodeBaseDef_ptr = NodalShotVariableNodeBaseDef::from_substruct(incoming_type_id, serialized);
		if (NodalShotVariableNodeBaseDef_ptr != nullptr) {
			return NodalShotVariableNodeBaseDef_ptr;
		}

		auto OrMissionSystemNodeDef_Tools_ptr = OrMissionSystemNodeDef_Tools::from_substruct(incoming_type_id, serialized);
		if (OrMissionSystemNodeDef_Tools_ptr != nullptr) {
			return OrMissionSystemNodeDef_Tools_ptr;
		}

		auto InputNodeBaseDef_ptr = InputNodeBaseDef::from_substruct(incoming_type_id, serialized);
		if (InputNodeBaseDef_ptr != nullptr) {
			return InputNodeBaseDef_ptr;
		}

		auto NodalShotEffectNodeBaseDef_ptr = NodalShotEffectNodeBaseDef::from_substruct(incoming_type_id, serialized);
		if (NodalShotEffectNodeBaseDef_ptr != nullptr) {
			return NodalShotEffectNodeBaseDef_ptr;
		}

		auto StringHashOutNodeDef_ptr = StringHashOutNodeDef::from_substruct(incoming_type_id, serialized);
		if (StringHashOutNodeDef_ptr != nullptr) {
			return StringHashOutNodeDef_ptr;
		}

		auto NotMissionSystemNodeDef_Tools_ptr = NotMissionSystemNodeDef_Tools::from_substruct(incoming_type_id, serialized);
		if (NotMissionSystemNodeDef_Tools_ptr != nullptr) {
			return NotMissionSystemNodeDef_Tools_ptr;
		}

		auto TestNodeDef_ptr = TestNodeDef::from_substruct(incoming_type_id, serialized);
		if (TestNodeDef_ptr != nullptr) {
			return TestNodeDef_ptr;
		}

		auto ActorNodeBaseDef_ptr = ActorNodeBaseDef::from_substruct(incoming_type_id, serialized);
		if (ActorNodeBaseDef_ptr != nullptr) {
			return ActorNodeBaseDef_ptr;
		}

		auto Vec3OutNodeDef_ptr = Vec3OutNodeDef::from_substruct(incoming_type_id, serialized);
		if (Vec3OutNodeDef_ptr != nullptr) {
			return Vec3OutNodeDef_ptr;
		}

		auto WeaponMacroTypeStateOutNodeDef_ptr = WeaponMacroTypeStateOutNodeDef::from_substruct(incoming_type_id, serialized);
		if (WeaponMacroTypeStateOutNodeDef_ptr != nullptr) {
			return WeaponMacroTypeStateOutNodeDef_ptr;
		}

		auto IntOutNodeDef_ptr = IntOutNodeDef::from_substruct(incoming_type_id, serialized);
		if (IntOutNodeDef_ptr != nullptr) {
			return IntOutNodeDef_ptr;
		}

		auto ComboNodeBaseDef_ptr = ComboNodeBaseDef::from_substruct(incoming_type_id, serialized);
		if (ComboNodeBaseDef_ptr != nullptr) {
			return ComboNodeBaseDef_ptr;
		}

		auto FloatOutNodeDef_ptr = FloatOutNodeDef::from_substruct(incoming_type_id, serialized);
		if (FloatOutNodeDef_ptr != nullptr) {
			return FloatOutNodeDef_ptr;
		}

		auto UIntOutNodeDef_ptr = UIntOutNodeDef::from_substruct(incoming_type_id, serialized);
		if (UIntOutNodeDef_ptr != nullptr) {
			return UIntOutNodeDef_ptr;
		}

		auto MathNodeBaseDef_ptr = MathNodeBaseDef::from_substruct(incoming_type_id, serialized);
		if (MathNodeBaseDef_ptr != nullptr) {
			return MathNodeBaseDef_ptr;
		}

		auto BooleanOutNodeDef_ptr = BooleanOutNodeDef::from_substruct(incoming_type_id, serialized);
		if (BooleanOutNodeDef_ptr != nullptr) {
			return BooleanOutNodeDef_ptr;
		}

		auto TestMakeStringNodeDef_ptr = TestMakeStringNodeDef::from_substruct(incoming_type_id, serialized);
		if (TestMakeStringNodeDef_ptr != nullptr) {
			return TestMakeStringNodeDef_ptr;
		}

		auto NodalShotConditionalNodeDef_ptr = NodalShotConditionalNodeDef::from_substruct(incoming_type_id, serialized);
		if (NodalShotConditionalNodeDef_ptr != nullptr) {
			return NodalShotConditionalNodeDef_ptr;
		}

		auto ConditionNodeBaseDef_ptr = ConditionNodeBaseDef::from_substruct(incoming_type_id, serialized);
		if (ConditionNodeBaseDef_ptr != nullptr) {
			return ConditionNodeBaseDef_ptr;
		}

		auto AssetReferenceNodeDef_ptr = AssetReferenceNodeDef::from_substruct(incoming_type_id, serialized);
		if (AssetReferenceNodeDef_ptr != nullptr) {
			return AssetReferenceNodeDef_ptr;
		}

		auto MissionNodeGameDef_Tools_ptr = MissionNodeGameDef_Tools::from_substruct(incoming_type_id, serialized);
		if (MissionNodeGameDef_Tools_ptr != nullptr) {
			return MissionNodeGameDef_Tools_ptr;
		}

		auto NodalShotEventNodeBaseDef_ptr = NodalShotEventNodeBaseDef::from_substruct(incoming_type_id, serialized);
		if (NodalShotEventNodeBaseDef_ptr != nullptr) {
			return NodalShotEventNodeBaseDef_ptr;
		}

		auto WAMNodeBaseDef_ptr = WAMNodeBaseDef::from_substruct(incoming_type_id, serialized);
		if (WAMNodeBaseDef_ptr != nullptr) {
			return WAMNodeBaseDef_ptr;
		}

		auto AndMissionSystemNodeDef_Tools_ptr = AndMissionSystemNodeDef_Tools::from_substruct(incoming_type_id, serialized);
		if (AndMissionSystemNodeDef_Tools_ptr != nullptr) {
			return AndMissionSystemNodeDef_Tools_ptr;
		}

		auto InitMissionGraphNodeGameDef_Tools_ptr = InitMissionGraphNodeGameDef_Tools::from_substruct(incoming_type_id, serialized);
		if (InitMissionGraphNodeGameDef_Tools_ptr != nullptr) {
			return InitMissionGraphNodeGameDef_Tools_ptr;
		}

		auto TestTriggerNodeDef_ptr = TestTriggerNodeDef::from_substruct(incoming_type_id, serialized);
		if (TestTriggerNodeDef_ptr != nullptr) {
			return TestTriggerNodeDef_ptr;
		}

		auto EmbeddedGraphNodeBaseDef_ptr = EmbeddedGraphNodeBaseDef::from_substruct(incoming_type_id, serialized);
		if (EmbeddedGraphNodeBaseDef_ptr != nullptr) {
			return EmbeddedGraphNodeBaseDef_ptr;
		}
 
		return nullptr;
	}
} // namespace rivet::ddl::generated
