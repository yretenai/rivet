// <auto-generated>
// rivet project
// Copyright (c) 2023 <https://github.com/yretenai/rivet>
// SPDX-License-Identifier: MPL-2.0

#include <rivet/ddl/generated/OutputNodeIntDef.hpp>
#include <rivet/ddl/generated/OutputNodeSignalDef.hpp>
#include <rivet/ddl/generated/OutputNodeUIntDef.hpp>
#include <rivet/ddl/generated/OutputNodeWeaponMacroTypeState.hpp>
#include <rivet/ddl/generated/OutputNodeActorDef.hpp>
#include <rivet/ddl/generated/OutputNodeBooleanDef.hpp>
#include <rivet/ddl/generated/OutputNodeStringDef.hpp>
#include <rivet/ddl/generated/OutputNodeStringHashDef.hpp>
#include <rivet/ddl/generated/SignalOutputNodeDef.hpp>
#include <rivet/ddl/generated/OutputNodeFloatDef.hpp>
#include <rivet/ddl/generated/EventInitializationOutputNodeDef.hpp>
#include <rivet/ddl/generated/OutputNodeVec3Def.hpp> 

#include <rivet/ddl/generated/OutputNodeBaseDef.hpp>

namespace rivet::ddl::generated {
	OutputNodeBaseDef::OutputNodeBaseDef([[maybe_unused]] const std::shared_ptr<const rivet::structures::rivet_serialized_object> &serialized): InputNodeBaseDef(serialized) {

	}

	[[nodiscard]] auto
	OutputNodeBaseDef::get_type_name() const noexcept -> std::string_view {
		return type_name;
	}

	[[nodiscard]] auto
	OutputNodeBaseDef::from_substruct(rivet_type_id incoming_type_id, const std::shared_ptr<const rivet::structures::rivet_serialized_object> &serialized) -> std::shared_ptr<OutputNodeBaseDef> {
		if (incoming_type_id == OutputNodeBaseDef::type_id) {
			return std::make_shared<OutputNodeBaseDef>(serialized);
		}

		auto OutputNodeVec3Def_ptr = OutputNodeVec3Def::from_substruct(incoming_type_id, serialized);
		if (OutputNodeVec3Def_ptr != nullptr) {
			return OutputNodeVec3Def_ptr;
		}

		auto OutputNodeFloatDef_ptr = OutputNodeFloatDef::from_substruct(incoming_type_id, serialized);
		if (OutputNodeFloatDef_ptr != nullptr) {
			return OutputNodeFloatDef_ptr;
		}

		auto OutputNodeStringHashDef_ptr = OutputNodeStringHashDef::from_substruct(incoming_type_id, serialized);
		if (OutputNodeStringHashDef_ptr != nullptr) {
			return OutputNodeStringHashDef_ptr;
		}

		auto EventInitializationOutputNodeDef_ptr = EventInitializationOutputNodeDef::from_substruct(incoming_type_id, serialized);
		if (EventInitializationOutputNodeDef_ptr != nullptr) {
			return EventInitializationOutputNodeDef_ptr;
		}

		auto SignalOutputNodeDef_ptr = SignalOutputNodeDef::from_substruct(incoming_type_id, serialized);
		if (SignalOutputNodeDef_ptr != nullptr) {
			return SignalOutputNodeDef_ptr;
		}

		auto OutputNodeBooleanDef_ptr = OutputNodeBooleanDef::from_substruct(incoming_type_id, serialized);
		if (OutputNodeBooleanDef_ptr != nullptr) {
			return OutputNodeBooleanDef_ptr;
		}

		auto OutputNodeActorDef_ptr = OutputNodeActorDef::from_substruct(incoming_type_id, serialized);
		if (OutputNodeActorDef_ptr != nullptr) {
			return OutputNodeActorDef_ptr;
		}

		auto OutputNodeWeaponMacroTypeState_ptr = OutputNodeWeaponMacroTypeState::from_substruct(incoming_type_id, serialized);
		if (OutputNodeWeaponMacroTypeState_ptr != nullptr) {
			return OutputNodeWeaponMacroTypeState_ptr;
		}

		auto OutputNodeUIntDef_ptr = OutputNodeUIntDef::from_substruct(incoming_type_id, serialized);
		if (OutputNodeUIntDef_ptr != nullptr) {
			return OutputNodeUIntDef_ptr;
		}

		auto OutputNodeStringDef_ptr = OutputNodeStringDef::from_substruct(incoming_type_id, serialized);
		if (OutputNodeStringDef_ptr != nullptr) {
			return OutputNodeStringDef_ptr;
		}

		auto OutputNodeSignalDef_ptr = OutputNodeSignalDef::from_substruct(incoming_type_id, serialized);
		if (OutputNodeSignalDef_ptr != nullptr) {
			return OutputNodeSignalDef_ptr;
		}

		auto OutputNodeIntDef_ptr = OutputNodeIntDef::from_substruct(incoming_type_id, serialized);
		if (OutputNodeIntDef_ptr != nullptr) {
			return OutputNodeIntDef_ptr;
		}
 
		return nullptr;
	}
} // namespace rivet::ddl::generated
