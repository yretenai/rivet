// rivet project
// Copyright (c) 2023 <https://github.com/yretenai/rivet>
// SPDX-License-Identifier: MPL-2.0

#pragma once

#include <string_view>

std::string_view default_base_struct_name = "rivet::structures::rivet_ddl_base";

std::string_view ddl_include = R"(#include <rivet/ddl/generated/%name%.hpp>)";
std::string_view ddl_enum_include = R"(#include <rivet/ddl/generated/enums/%enum_name%.hpp>)";
std::string_view ddl_bitset_include = R"(#include <rivet/ddl/generated/bitsets/%bitset_name%.hpp>)";

std::string_view template_struct_hpp = R"(// <auto-generated>
// rivet project
// Copyright (c) 2023 <https://github.com/yretenai/rivet>
// SPDX-License-Identifier: MPL-2.0

#pragma once

// clang-format off

#include <cstdint>
#include <memory>
#include <string_view>
#include <vector>

#include <rivet/hash/type_id.hpp>
#include <rivet/rivet_array.hpp>
#include <rivet/rivet_keywords.hpp>
#include <rivet/structures/rivet_serialization.hpp>

%includes%

namespace rivet::ddl::generated {
%fwd_decls%

	struct RIVET_DDL_SHARED %struct_name% : %base_struct_name% {
		constexpr const static std::string_view type_name = "%struct_name%";
		constexpr const static rivet::rivet_type_id type_id = 0x%struct_id%;

%type_ids%

		explicit %struct_name%() = default;
		explicit %struct_name%([[maybe_unused]] const std::shared_ptr<const rivet::structures::rivet_serialized_object> &serialized);

%fields%

		[[nodiscard]] auto
		get_type_name() const noexcept -> std::string_view override;

		[[nodiscard]] static auto
		from_substruct(rivet_type_id incoming_type_id, const std::shared_ptr<const rivet::structures::rivet_serialized_object> &serialized) -> std::shared_ptr<%struct_name%>;
	};
} // namespace rivet::ddl::generated

// clang-format on
)";

std::string_view template_enum_hpp = R"(// <auto-generated>
// rivet project
// Copyright (c) 2023 <https://github.com/yretenai/rivet>
// SPDX-License-Identifier: MPL-2.0

#pragma once

// clang-format off

#include <cstdint>
#include <string_view>
#include <array>

#include <rivet/hash/type_id.hpp>
#include <rivet/rivet_keywords.hpp>

namespace rivet::ddl::generated {
	constexpr const static std::string_view %enum_name%_type_name = "%enum_name%";
	constexpr const static rivet::rivet_type_id %enum_name%_type_id = 0x%enum_id%;

	constexpr const static %enum_value_type% %enum_name%_values = {
%decl_fields%
	};

	enum class %enum_name% : uint64_t {
%fields%
	};
} // namespace rivet::ddl::generated

// clang-format on
)";

std::string_view template_struct_cpp = R"(// <auto-generated>
// rivet project
// Copyright (c) 2023 <https://github.com/yretenai/rivet>
// SPDX-License-Identifier: MPL-2.0

%includes%

#include <rivet/ddl/generated/%struct_name%.hpp>

namespace rivet::ddl::generated {
	%struct_name%::%struct_name%([[maybe_unused]] const std::shared_ptr<const rivet::structures::rivet_serialized_object> &serialized): %base_struct_name%(serialized) {
%field_init%
	}

	[[nodiscard]] auto
	%struct_name%::get_type_name() const noexcept -> std::string_view {
		return type_name;
	}

	[[nodiscard]] auto
	%struct_name%::from_substruct(rivet_type_id incoming_type_id, const std::shared_ptr<const rivet::structures::rivet_serialized_object> &serialized) -> std::shared_ptr<%struct_name%> {
%substructs%
		return nullptr;
	}
} // namespace rivet::ddl::generated
)";

std::string_view template_registration_cpp = R"(// <auto-generated>
// rivet project
// Copyright (c) 2023 <https://github.com/yretenai/rivet>
// SPDX-License-Identifier: MPL-2.0

#include <rivet/ddl/rivet_ddl.hpp>
#include <rivet/structures/rivet_serialization.hpp>

%includes%

namespace rivet::ddl {
	void
	register_ddl_types() {
%type_registrations%
	}
} // namespace rivet::ddl
)";

std::string_view meson_build = R"(ddl_codegen_files += [
%cxx_files%
]
)";

std::string_view template_registration = R"(		rivet::structures::register_ddl_type<rivet::ddl::generated::%type_name%>();)";

std::string_view template_struct_fwd_decl = R"(	struct %struct_name%;)";
std::string_view template_struct_field = R"(		%field_type% %field_name% {};)";
std::string_view template_struct_field_init = R"(		%field_name% = %field_init%;)";

std::string_view template_enum_field = R"(		%field_name%,)";
std::string_view template_enum_field_decl = R"(		"%field_name%",)";
std::string_view template_enum_field_value_type = R"(std::array<std::string_view, %enum_count%>)";

std::string_view template_bitset_field = R"(		%field_name% = 0x%field_value%,)";
std::string_view template_bitset_field_decl = R"(		std::make_tuple("%field_name%", 0x%field_value%),)";
std::string_view template_bitset_field_value_type = R"(std::array<std::tuple<std::string_view, uint64_t>, %enum_count%>)";

std::string_view template_struct_field_value = R"(serialized->get_%field_type%(%field_name%_type_id))";
std::string_view template_struct_field_enum = R"(serialized->get_enum<%field_type%>(%field_name%_type_id, %field_type%_values))";
std::string_view template_struct_field_bitset = R"(serialized->get_bitset<%field_type%>(%field_name%_type_id, %field_type%_values))";
std::string_view template_struct_field_array = R"(serialized->get_%field_type%s(%field_name%_type_id))";
std::string_view template_struct_field_enum_array = R"(serialized->get_enums<%field_type%>(%field_name%_type_id, %field_type%_values))";
// todo: std::string_view template_struct_field_bitset_array = R"(serialized->get_bitsets<%field_type%>(%field_name%_type_id, %field_type%_values))";
std::string_view template_struct_field_struct = R"(serialized->unwrap_into<%field_type%>(%field_name%_type_id))";
std::string_view template_struct_field_struct_array = R"(serialized->unwrap_into_many<%field_type%>(%field_name%_type_id))";
std::string_view template_struct_field_any = R"(serialized->get_field(%field_name%_type_id))";

std::string_view template_struct_type_id = R"(		constexpr const static std::string_view %name%_type_name = "%name%";
		constexpr const static rivet::rivet_type_id %name%_type_id = 0x%id%;)";

std::string_view template_struct_substruct = R"(		if (incoming_type_id == %struct_name%::type_id) {
			return std::make_shared<%struct_name%>(serialized);
		}
)";

std::string_view template_struct_substruct_recur = R"(		auto %struct_name%_ptr = %struct_name%::from_substruct(incoming_type_id, serialized);
		if (%struct_name%_ptr != nullptr) {
			return %struct_name%_ptr;
		}
)";

// reserved keywords from https://en.cppreference.com/w/cpp/keyword
std::array<std::string_view, 93> reserved_keywords = {
	"alignas",	"alignof",		"and",		 "and_eq",	  "asm",		  "auto",	   "bitand",		"bitor",
	"bool",		"break",		"case",		 "catch",	  "char",		  "char8_t",   "char16_t",		"char32_t",
	"class",	"compl",		"concept",	 "const",	  "consteval",	  "constexpr", "constinit",		"const_cast",
	"continue", "co_await",		"co_return", "co_yield",  "decltype",	  "default",   "delete",		"do",
	"double",	"dynamic_cast", "else",		 "enum",	  "explicit",	  "export",	   "extern",		"false",
	"float",	"for",			"friend",	 "goto",	  "if",			  "inline",	   "int",			"long",
	"mutable",	"namespace",	"new",		 "noexcept",  "not",		  "not_eq",	   "nullptr",		"operator",
	"or",		"or_eq",		"private",	 "protected", "public",		  "reflexpr",  "register",		"reinterpret_cast",
	"requires", "return",		"short",	 "signed",	  "sizeof",		  "static",	   "static_assert", "static_cast",
	"struct",	"switch",		"template",	 "this",	  "thread_local", "throw",	   "true",			"try",
	"typedef",	"typeid",		"typename",	 "union",	  "unsigned",	  "using",	   "virtual",		"void",
	"volatile", "wchar_t",		"while",	 "xor",		  "xor_eq",
};
